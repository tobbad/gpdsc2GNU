#!/usr/bin/python3
# -*- coding: utf-8 -*-
"""
    Tool to turn a gpdsc file generated by stm32cubemx into a makefile.
    Created on 18.2.2016
    @author: Tobias Badertscher

"""
import sys
import os
import inspect
import xml.etree.ElementTree as ET
import json
from jinja2 import Template
import re
import glob
import tkinter as tk
import tkinter.filedialog as filedialog
import functools

thisModule = sys.modules[__name__]
svnRev=("$Rev: 6738 $").split()[1]
svnDate=("$Date: 2012-08-08 14:05:16 +0200 (Mi, 08 Aug 2012) $").split()[1]
pythonVersion=[int(i.replace('+','')) for i in sys.version.split()[0].split('.')]
exportPrefix='ex_'
scriptPath=os.sep.join(__file__.split(os.sep)[0:-1])

################
#
# Helpers
#
################
class ConfigurationCreator(tk.Frame):
    def __init__(self, fields, master=None):
        tk.Frame.__init__(self, master)
        self.__root = master
        self._fields = fields
        self.result = {}
        self.entryWid={}
        for desc, name, value in self._fields:
            self.result[name] = ""
        self.dir_opt = options = {}
        options['initialdir'] = ''
        options['mustexist'] = True
        options['parent'] = self.__root
        options['title'] = "Configuration entry"
        self.createWidgets()

    def createWidgets(self):
        self.grid()
        for row, (desc, field, value) in enumerate(self._fields):
            lbl = tk.Label(self,text = desc)
            lbl.grid(row = row, column = 0, sticky=(tk.W))
            self.entryWid[field] = tk.Entry(self, textvariable=value)
            self.entryWid[field].grid(row = row, column = 1, sticky=(tk.N))
            btn = tk.Button(text = "Browse", command=functools.partial(self.getFolder, field))
            btn.grid(row = row, column = 1,sticky=(tk.N,))
        self.QUIT = tk.Button(self, text="QUIT", fg="red", command=self.__root.destroy)
        self.QUIT.grid(column=0, row=len(self._fields), columnspan=2, sticky= (tk.W, tk.E))

    def getFolder(self, field):
        path =  filedialog.askdirectory(**self.dir_opt)
        self.result[field]= path.split(os.sep)
        self.entryWid[field].delete(0, tk.END)
        self.entryWid[field].insert(0, path)



class Configuration(object):

    __CONFIG = (".config","gpdsc2gnu.json")
    __ENTRIES = ( ("Location of stm32CubeMx", 'cubemx_location',""),
                  ("Location of stm32cube_fw Repository",'repository_location',"oga oga oga"))

    def __init__(self):
        path = tuple(os.environ['HOME'].split(os.sep))+self.__CONFIG
        self.__cfName = os.sep.join(path)
        if not os.path.exists(self.__cfName):
            self._ModifyConf()
        with open(self.__cfName) as fd:
            self._conf = json.load(fd)
        if len(self._conf) < len(self.__ENTRIES):
            self._ModifyConf()

    def _ModifyConf(self):
        root = tk.Tk()
        app = ConfigurationCreator(self.__ENTRIES, master=root)
        app.mainloop()
        with open(self.__cfName,'w') as fd:
            json.dump(app.result, fd)
        self._conf = app.result

    @property
    def families(self):
        path = tuple(self._conf['cubemx_location'])+('db','families.xml')
        return os.sep.join(path)

    @property
    def repository(self):
        path = tuple(self._conf['repository_location'])
        return path

    def getProcSer(self, processor):
        series, item  = re.match(r"stm32([lf][0-9])([0-9x]+)",processor).groups()
        proc = series+item
        return proc, series

    def getCubeBasePath(self, processor, cubeVersion):
        repoPat = "STM32Cube_FW_%s_V%s"
        proc, series = self.getProcSer(processor)
        if len(cubeVersion.split('.')) != 3:
            cubeVersion +=".0"
        cubeFolder = repoPat % (series.upper(), cubeVersion)
        return self.repository + (cubeFolder,)

    def startup(self, processor='stm32l476', cubeVersion='1.3.0'):
        supFolder = ('Drivers', 'CMSIS', 'Device', 'ST', 'STM32L4xx', 'Source', 'Templates', 'gcc')
        setupFilePat = "startup_stm32%s*.s"
        proc, series = self.getProcSer(processor)
        cubePath = self.getCubeBasePath(processor, cubeVersion)
        path = os.sep.join(cubePath + supFolder + (setupFilePat % (proc),))
        file = glob.glob(path)
        if len(file)==1:
            return file[0]
        return None


class GPDSC(dict):

    def __init__(self, fName):
        print("Create %s" % (self.__class__.__name__))
        self._conf = Configuration()
        self._conf.startup()
        self._proj = None
        self._project_location = tuple(os.path.dirname(fName).split(os.sep))
        self._tree = ET.parse(fName)
        self._missingFiles = []
        self['filename']= os.path.basename(fName)
        self['target'] = self.target
        self['SRC'] = self.source
        self['SRC_FOLDER'] = self.source_folder
        self['ASM'] = self.assembler
        self['ASM_FOLDER'] = self.assembler_folder
        self['INCLUDE']=self.include
        self['LINKER']='linker.ld'

    def getPath(self, path):
        path = path.split('/')
        if len(path)==1:
            path = path[0].split('\\')
        return os.sep.join(path)

    @property
    def target(self):
        el = self._tree.findall('./name')
        return el[0].text

    def _checkFiles(self):
        for f in self.source:
            if not os.path.exists(f):
                print("File %s does not exist" % f)

    def _getFiles(self, category):
        ret = []
        srcIter = self._tree.findall('.//file')
        for item in srcIter:
            if item.attrib['category'] == category:
                path = self.getPath(item.attrib['name'])
                if "condition" in item.attrib:
                    if item.attrib["condition"]== "GCC Toolchain":
                        ret.append(path)
                else:
                    ret.append(path)
                absPath = os.sep.join(self._project_location + (path, ))
                if  not os.path.exists(absPath) and not path in self._missingFiles:
                    print("File %s does not exist" % absPath)
                    self._missingFiles.append(path)
        return ret

    def addSrcCode(self, path):
        path = self.getPath(path)
        if path not in self['SRC']:
            self['SRC'].append(path)
            self['SRC_FOLDER'].append(os.path.dirname(path))

    def addAsmCode(self, path):
        path = self.getPath(path)
        if path not in self['ASM']:
            self['ASM'].append(path)
            self['ASM_FOLDER'].append(os.path.dirname(path))

    def _getFolders(self, category):
        files = self._getFiles(category)
        ret = []
        for f in files:
            path = os.path.dirname(f)
            if not path in ret:
                ret.append(path)
        return ret

    @property
    def source(self):
        return self._getFiles('source')

    @property
    def assembler(self):
        return self._getFiles('sourceAsm')

    @property
    def include(self):
        return self._getFolders('header')

    @property
    def source_folder(self):
        return self._getFolders('source')

    @property
    def assembler_folder(self):
        return self._getFolders('sourceAsm')

    @property
    def location(self):
        return self._project_location

    def copyMissingFiles(self):
        for f in self._missingFiles:
            print(f)


class Makefile(object):

    __TPL_FILE = 'Makefile.tpl'

    def __init__(self, proj):
        self._proj = proj

    def generate(self, toFile = False):
        tplData = None
        ret = None
        with open(scriptPath+os.sep+self.__TPL_FILE,'r') as fd:
            tplData = fd.read()
        if tplData:
            tpl=Template(tplData)
            ret = tpl.render(self._proj)
        if toFile:
            fName = os.sep.join(self._proj.location+("Makefile",))
            with open(fName, 'w') as fd:
                fd.write(ret)
        return ret

class Linker(object):

    __TPL_FILE = 'linker.tpl'

    def __init__(self, proj):
        self._proj = proj
        self._data={}
        self._data['flashbase']= "0x08000000"
        self._data['flashsizeKB']= 1024
        self._data['isrsizeKB']= 1
        self._data['flashtextbase'] = '0x08020000'
        self._data['flashtextsizeKB']= int((self._data['flashsizeKB']*1024-(int(self._data['flashtextbase'], 16)-int(self._data['flashbase'],16)))/1024)
        self._data['ramsizeKB']= 96
        self._data['ram2sizeKB']= 32

    def generate(self, toFile= False):
        tplData = None
        ret = None
        with open(scriptPath+os.sep+self.__TPL_FILE,'r') as fd:
            tplData = fd.read()
        if tplData:
            tpl=Template(tplData)
            ret = tpl.render(self._data)
        if toFile:
            fName = os.sep.join(self._proj.location+("linker.ld",))
            with open(fName, 'w') as fd:
                fd.write(ret)
        return ret


#######################################
#
# script functions
#
#######################################
def ex_make(*para):
    '''
    make project_description.gpdsc
    Turn given gpdsc file into a Makefile for building this project.
    '''
    print("Run make")
    if len(para[0])==0:
        Usage(["No configure filename given",])
    proj = GPDSC(para[0][0])
    proj.addSrcCode('Drivers/CMSIS/Device/ST/STM32L4xx/Source/Templates/system_stm32l4xx.c')
    proj.addAsmCode('Drivers/CMSIS/Device/ST/STM32L4xx/Source/Templates/gcc/startup_stm32l476xx.s')
    mk = Makefile(proj)
    data = mk.generate(True)
    ld = Linker(proj)
    ld.generate(True)


    return

def ex_configure(*para):
    '''
    config
    Configure default location of needed files.
    '''
    print("Run configure")
    cfName = getConfigFName()

    return


#######################################
#
# Collect all commands in this script.
#
#######################################
def getModuleInfo():
    #print("Items in the current context:")
    exPrefixlen=len(exportPrefix)
    cmds={}
    moduleDoc=""
    for name, item in inspect.getmembers(thisModule):
        if inspect.isfunction(item):
            if exportPrefix == item.__name__[0:exPrefixlen]:
                cmds[item.__name__]=item
        if inspect.ismodule(item):
            moduleDoc=item.__doc__
    return cmds, moduleDoc

def cleanUpTextList(tList):
    '''
    Remove empty lines in a \n separated test list
    '''
    text=[]
    for i in tList:
        i=i.strip()
        if len(i)>0:
            text.append(i)
    return text
#######################################
#
# Usage and main entrance of skript
#
#######################################
def Usage(error=None):
    skriptname=sys.argv[0].split(os.sep)[-1]
    CnCDict, moduleDoc =getModuleInfo()
    sCList  =   [i for i in CnCDict.keys()]
    sCList.sort()
    text=cleanUpTextList(moduleDoc.split("\n"))
    cmdStr="command"
    maxCmdLen=len(cmdStr)
    for cmd in sCList:
        maxCmdLen = maxCmdLen if len(cmd)<maxCmdLen else len(cmd)
    commentPos=12
    text.extend([
          "(SVN-Revision %s)" % (svnRev),
          "",
          "Comand line:",
          "  %s cmd parameter" % skriptname,
          " "*commentPos+"'cmd' and 'parameter' according to the following list:",
          " "*commentPos+"(Parameters in [xxx] are optional and should - if used - entered without [])",
          ])
    cmdHeader="    command      parameter"
    if pythonVersion[1]>5:
        cmdHeader="    {cmd:{cwidth}} {b}".format(cmd=cmdStr,b="Parameter(s)",cwidth=maxCmdLen+1)
    #text.append(cmdHeader)
    for cmdName in sCList:
        if CnCDict[cmdName].__doc__!=None:
            cmdInfo=cleanUpTextList(CnCDict[cmdName].__doc__.split("\n"))
            cmdName=cmdInfo[0].split()[0].strip()
            para=" ".join(cmdInfo[0].split()[1:])
            if (pythonVersion[0]==2 and pythonVersion[1]>5) or (pythonVersion[0]>2):
                text.append("    {a:{cwidth}} {b}".format(a=cmdName,b=para,cwidth=maxCmdLen+1))
            else:
                text.append("    %s %s" % (cmdInfo[0].strip(),cmdInfo[1].strip()))
            if len(cmdInfo)>1:
                for line in cmdInfo[1:]:
                    text.append(" "*commentPos+line.strip())
    res="\n".join(text)
    etext=[]
    if error != None:
        error.insert(0,"ERROR:")
        maxlen=max([len(i) for i in error])
        etext.append("*"*(maxlen+4))
        etext.append("*"*(maxlen+4))
        for i in error:
            etext.append("* "+i+"%s *" % (" "*(maxlen-len(i))))
        etext.append("*"*(maxlen+4))
        etext.append("*"*(maxlen+4))
        print("\n".join(etext))
    print(res)
    sys.exit()

def main():
    if len(sys.argv)<2:
        Usage(["No Command given",])
    cmd=sys.argv[1]
    cmds, moduleDoc = getModuleInfo()
    iCmd='ex_'+cmd
    if iCmd not in cmds:
        Usage()
    cmds[iCmd](sys.argv[2:])

if __name__ == '__main__':
    main()

